// tests/audit-logger.test.js â€” Tests for Audit Logger
import { describe, it, beforeEach } from 'node:test';
import assert from 'node:assert/strict';
import { AuditLogger } from '../audit-logger.js';

// Mock localStorage and sessionStorage for Node.js testing
global.localStorage = {
  data: {},
  getItem(key) {
    return this.data[key] || null;
  },
  setItem(key, value) {
    this.data[key] = value;
  },
  removeItem(key) {
    delete this.data[key];
  },
  clear() {
    this.data = {};
  }
};

global.sessionStorage = {
  data: {},
  getItem(key) {
    return this.data[key] || null;
  },
  setItem(key, value) {
    this.data[key] = value;
  },
  removeItem(key) {
    delete this.data[key];
  },
  clear() {
    this.data = {};
  }
};

// Mock navigator for Node.js
global.navigator = {
  userAgent: 'Node.js Test Runner'
};

describe('AuditLogger Tests', () => {
  beforeEach(() => {
    // Clear storage before each test
    localStorage.clear();
    sessionStorage.clear();
  });

  describe('generateWatermark', () => {
    it('should generate watermark with all required fields', () => {
      const watermark = AuditLogger.generateWatermark();
      
      assert.ok(watermark.generated_by);
      assert.strictEqual(watermark.generated_by, 'TaxSyncForDrivers');
      assert.ok(watermark.version);
      assert.strictEqual(watermark.version, '1.0.0');
      assert.ok(watermark.generated_at);
      assert.ok(watermark.disclaimer);
      assert.strictEqual(watermark.cra_compliant, true);
      assert.ok(watermark.audit_trail_id);
      assert.ok(watermark.audit_trail_id.startsWith('audit-'));
    });

    it('should generate unique audit trail IDs', async () => {
      const watermark1 = AuditLogger.generateWatermark();
      // Small delay to ensure different timestamp
      await new Promise(resolve => setTimeout(resolve, 10));
      const watermark2 = AuditLogger.generateWatermark();
      
      assert.notStrictEqual(watermark1.audit_trail_id, watermark2.audit_trail_id);
    });
  });

  describe('addWatermarkToExport', () => {
    it('should add watermark to CSV export', () => {
      const csvData = 'Line,Description,Amount\n9270,Fuel,8500';
      const watermarked = AuditLogger.addWatermarkToExport(csvData, 'csv');
      
      assert.ok(watermarked.includes('Generated by TaxSyncForDrivers'));
      assert.ok(watermarked.includes('Audit Trail ID:'));
      assert.ok(watermarked.includes(csvData));
      assert.ok(watermarked.includes('v1.0.0'));
      assert.ok(watermarked.includes('This is an estimate'));
    });

    it('should add watermark to JSON export', () => {
      const jsonData = { income: 45000, expenses: 12000 };
      const watermarked = AuditLogger.addWatermarkToExport(jsonData, 'json');
      
      assert.ok(watermarked.generated_by);
      assert.ok(watermarked.version);
      assert.ok(watermarked.audit_trail_id);
      assert.strictEqual(watermarked.data, jsonData);
    });
  });

  describe('getOrCreateSessionId', () => {
    it('should create session ID if not exists', () => {
      const sessionId = AuditLogger.getOrCreateSessionId();
      
      assert.ok(sessionId);
      assert.ok(sessionId.startsWith('session-'));
    });

    it('should return same session ID on subsequent calls', () => {
      const sessionId1 = AuditLogger.getOrCreateSessionId();
      const sessionId2 = AuditLogger.getOrCreateSessionId();
      
      assert.strictEqual(sessionId1, sessionId2);
    });
  });

  describe('log', () => {
    it('should log action with metadata', () => {
      const logId = AuditLogger.log('test_action', { test: 'data' }, { extra: 'metadata' });
      
      assert.ok(logId.startsWith('audit-'));
      
      const logs = AuditLogger.getAuditLog();
      assert.strictEqual(logs.length, 1);
      
      const log = logs[0];
      assert.strictEqual(log.id, logId);
      assert.strictEqual(log.action, 'test_action');
      assert.strictEqual(log.data.test, 'data');
      assert.strictEqual(log.metadata.extra, 'metadata');
      assert.ok(log.metadata.sessionId);
      assert.ok(log.metadata.userAgent);
      assert.ok(log.timestamp);
      assert.strictEqual(log.version, '1.0.0');
    });

    it('should keep only last 1000 entries', () => {
      // Add 1005 log entries
      for (let i = 0; i < 1005; i++) {
        AuditLogger.log('test_action', { index: i });
      }
      
      const logs = AuditLogger.getAuditLog();
      assert.strictEqual(logs.length, 1000);
      
      // First log should be index 5 (0-4 were removed)
      assert.strictEqual(logs[0].data.index, 5);
      assert.strictEqual(logs[logs.length - 1].data.index, 1004);
    });
  });

  describe('logCalculation', () => {
    it('should log calculation with metadata', () => {
      const logId = AuditLogger.logCalculation({
        income: 45000,
        deductions: 12000,
        taxSavings: 3000
      });
      
      assert.ok(logId.startsWith('audit-'));
      
      const logs = AuditLogger.getAuditLog();
      const lastLog = logs[logs.length - 1];
      
      assert.strictEqual(lastLog.action, 'calculation');
      assert.strictEqual(lastLog.data.income, 45000);
      assert.strictEqual(lastLog.data.deductions, 12000);
      assert.ok(lastLog.metadata.sessionId);
    });
  });

  describe('logExport', () => {
    it('should log export action', () => {
      const logId = AuditLogger.logExport('T2125', { format: 'csv', year: 2025 });
      
      assert.ok(logId.startsWith('audit-'));
      
      const logs = AuditLogger.getAuditLog();
      const lastLog = logs[logs.length - 1];
      
      assert.strictEqual(lastLog.action, 'export');
      assert.strictEqual(lastLog.data.exportType, 'T2125');
      assert.strictEqual(lastLog.data.format, 'csv');
    });
  });

  describe('logReceiptUpload', () => {
    it('should log receipt upload', () => {
      const expense = { date: '2025-01-20', amount: 85.50, vendor: 'Shell' };
      const logId = AuditLogger.logReceiptUpload('receipt-123', expense);
      
      assert.ok(logId.startsWith('audit-'));
      
      const logs = AuditLogger.getAuditLog();
      const lastLog = logs[logs.length - 1];
      
      assert.strictEqual(lastLog.action, 'receipt_upload');
      assert.strictEqual(lastLog.data.receiptId, 'receipt-123');
      assert.strictEqual(lastLog.data.expense.amount, 85.50);
    });
  });

  describe('getAuditLog', () => {
    it('should return empty array when no logs exist', () => {
      const logs = AuditLogger.getAuditLog();
      assert.strictEqual(Array.isArray(logs), true);
      assert.strictEqual(logs.length, 0);
    });

    it('should return all logs', () => {
      AuditLogger.log('action1', { data: 1 });
      AuditLogger.log('action2', { data: 2 });
      AuditLogger.log('action3', { data: 3 });
      
      const logs = AuditLogger.getAuditLog();
      assert.strictEqual(logs.length, 3);
    });
  });

  describe('getLogsByAction', () => {
    it('should filter logs by action type', () => {
      AuditLogger.logCalculation({ income: 45000 });
      AuditLogger.logExport('T2125', { format: 'csv' });
      AuditLogger.logCalculation({ income: 50000 });
      
      const calculationLogs = AuditLogger.getLogsByAction('calculation');
      assert.strictEqual(calculationLogs.length, 2);
      
      const exportLogs = AuditLogger.getLogsByAction('export');
      assert.strictEqual(exportLogs.length, 1);
    });
  });

  describe('getLogsByDateRange', () => {
    it('should filter logs by date range', () => {
      // Create logs with specific timestamps
      const log1 = AuditLogger.log('action1', { data: 1 });
      
      // Get the timestamp from the log
      const logs = AuditLogger.getAuditLog();
      const timestamp = new Date(logs[0].timestamp);
      
      // Create date range around the log
      const startDate = new Date(timestamp.getTime() - 1000 * 60 * 60); // 1 hour before
      const endDate = new Date(timestamp.getTime() + 1000 * 60 * 60); // 1 hour after
      
      const filteredLogs = AuditLogger.getLogsByDateRange(startDate.toISOString(), endDate.toISOString());
      assert.strictEqual(filteredLogs.length, 1);
    });
  });

  describe('getLogsByTaxYear', () => {
    it('should filter logs by tax year', () => {
      // We can't easily mock timestamps in the log, so we'll just verify the function exists
      // and doesn't throw
      const logs2025 = AuditLogger.getLogsByTaxYear(2025);
      assert.strictEqual(Array.isArray(logs2025), true);
    });
  });

  describe('generateAuditReport', () => {
    it('should generate audit report for tax year', () => {
      AuditLogger.logCalculation({ income: 45000 });
      AuditLogger.logExport('T2125', { format: 'csv' });
      AuditLogger.logCalculation({ income: 50000 });
      
      const report = AuditLogger.generateAuditReport(2026);
      
      assert.ok(report);
      assert.strictEqual(report.year, 2026);
      assert.ok(report.totalEntries >= 0);
      assert.ok(report.actionBreakdown);
      assert.ok(Array.isArray(report.logs));
    });
  });

  describe('exportAuditLog', () => {
    it('should export audit log as JSON', () => {
      AuditLogger.log('test_action', { data: 'test' });
      
      const jsonExport = AuditLogger.exportAuditLog('json');
      assert.ok(jsonExport);
      
      const parsed = JSON.parse(jsonExport);
      assert.strictEqual(Array.isArray(parsed), true);
      assert.strictEqual(parsed.length, 1);
    });

    it('should export audit log as CSV', () => {
      AuditLogger.log('test_action', { data: 'test' });
      
      const csvExport = AuditLogger.exportAuditLog('csv');
      assert.ok(csvExport.includes('ID,Timestamp,Version,Action'));
      assert.ok(csvExport.includes('test_action'));
    });
  });

  describe('clearOldLogs', () => {
    it('should clear logs older than retention period', () => {
      // Add a log
      AuditLogger.log('test_action', { data: 'test' });
      
      // Clear logs older than 6 years (won't delete the recent log)
      const deletedCount = AuditLogger.clearOldLogs(6);
      
      // Since we just created the log, it shouldn't be deleted
      assert.strictEqual(deletedCount, 0);
      
      const logs = AuditLogger.getAuditLog();
      assert.strictEqual(logs.length, 1);
    });
  });
});
